# MFDP
New repo for MFDP service

Результаты разведочного анализа содержатся в папке EDA и соответствующем Readme.md

Результаты тюнинга содержатся в папке tuning и соответствующем Readme.md

В данном файле коротко описана структура итогового проекта.

## Как запустить итоговое приложение в докере
! Важно !

requirements.txt содержит слепок всех пакетов IDE разработчика, вычищенных таким образом, чтобы при установке в новый контейнер не возникало конфликтов. Зависимостей много, и их установка занимает от 120 до 150 секунд. Идеальным решением было бы собрать проект на нулевой venv, однако в установленные сроки такая работа не представляется возможной.

Приложение зависит от двух конфигурационных файлов:
* /app/.env - файл с глобальными настройками приложения
* /app/services/ml/params.py - файл с настройками параметров соединения к сервису RMQ

По указанным путям лежат файлы-шаблоны с примерами заполнения. Критически важные места уже прописаны в соответствии с конфигурацией NGINX и docker-compose, остальные параметры заполняются в соответствии:
* _SECRET_KEY=_ фраза для хэширования пароля. Локально уникальная
* _COOKIE_NAME=_ наименование куков для авторизации через куки. Скопировано из примера реализации от Юрия.

После создания файлов .env и params.py необходимо выполнить команду docker-compose up. Произойдёт следующее:
1. Будут установлены requirements.txt. Это займёт время около 2х минут.
2. Будут запущены следующие контейнеры:
   1. api - бэкэнд приложения.
   2. web - nginx прокси, настроенный на gui
   3. rabbitmq - инстанс очереди
   4. postgres - инстанс БД
   5. worker - файл с воркером, зависит от запуска rabbitmq, будет перезапускаться до тех пор, пока не запустится кролик. Не удалось настроить запуск по хэлсчеку, поэтому примерно за 10 секунд запуска кролика воркер попробует рестатртануть 5 раз. Это нормальное поведение. Воркер реплицирован. Количество реплик можно настроить в файле docker-compose.
   6. gui - streamlit приложение, которое проксируется nginx по 80 и 443 портам для http и httpx соответственно, доступно по запросу localhost.

У вас должна получиться следующая картина:
![docker.png](images%2Fdocker.png)

Для работы системы в мерж добавлены артефакты с датасетом и моделью. Это не целевое решение, но т.к. они не занимают много места, решил всё же оставить.


## Объектная модель

![om_mfdp.png](images%2Fom_mfdp.png)

Объектную модель я постарался сделать максимально строгой. 

На модели присутствуют абстракции "Регистрация" и "Авторизация" как задел под будущие необходимые методы и хранилища.

Модель расширяется до транзакционной оплаты с минимальными доработками. Транзакционность предсказаний мной была положена как излишняя, вместо этого создана система задач.

## Модель классов
![cd_mfdp.png](images%2Fcd_mfdp.png)

## Архитектура системы
![arch.png](images%2Farch.png)

## Интерфейс openAPI

Структура БД, функции работы с ней и openAPI интерфейс:
* Модуль **_database_** - функции подключения к локальной БД. Все чувствительные данные загружены из конфига. 
* Модуль **_models_** - описание SQLModel классов БД и их методов. Децентрализовал реализацию модели для лучшей поддержки. Решение сэкономило огромное количество времени на CRUD слое.
* Модуль **_routes_** - описание роутеров на специфичные классам функции. 
* Модуль **_services_** - вспомогательные операции.
  * **_auth_** - сервис аутентификации по кукам.
  * **_crud_** - crud слой. Полный набор crud операций классов.
* Модуль **_artifacts_** - файл модели.
* Модуль **_auth_** - блок аутентификации, хэширования пароля и работы с токенами.
* Папка **_app_** - файл запуска приложения. При старте вызывается, в том числе, функция conn - создающая структуру БД, но не пересоздающая её. Для пересоздания таблиц в БД используйте каскадное удаление таблиц вручную.

## Подключение очереди сообщений
Структура RMQ:
* Модуль **_services/ml/_**
  * Файл конфига (не отслеживаемый в git, стандартной структуры для **_pika.ConnectionParameters_**). Пример конфига в **_params.template.py_**.
  * Файл с воркером.
* Поведение следующее:
  * Producer (Consumer) отправляет в очередь prediction сообщение со сгенерированным таском, corr_id и именем очереди для ответа.
  * Воркер принимает сообщение, выполняет действия с созданием таска, предиктом, обновлениями сущностей и отправляет колбэк в очередь, которую получил от Producer.
  * Producer же в свою очередь держит соединение ровно до получения ответа с интересующим его corr_id. После чего закрывает соединение, получает предикт и выводит пользователю.
  * Если подключить несколько воркеров к очереди, они будут разбирать сообщения по очереди. Можно настроить в докере отдельно (параметр deploy.replicas).

## GUI
В данном блоке реализован простой GUI на базе библиотеки streamlit, позволяющий покрыть следующие функции:
* Регистрация
* Авторизация
  * Реализована авторизация через stx.cookie_manager - хранение токена с временем жизни в 10 минут и передачей состояния авторизации с стейт сессии. По страницам приложения токен пробрасывается через стейт.
  * Существует проблема промышленного решения - авторизация при модели лицензионной продажи сервиса. Проблема заключается в том, что развёртывание сервиса внутри организации неминуемо ведёт к внутреннему тиражу решения в этой организации и устранению поставщика ПО от его (ПО) обслуживания. В данной работе это проблема не решалась.
* Отправка данных для предсказания (и само предсказание с выводом результата и минимальной информацией по интерпретации)
  * Отправка данных имеет обработку параметра None, доступного для данной модели. Соответствующее поле отмечено на GUI.
  * Интерпретация
  * Словарь

Структура блока GUI:
* ./streamlit - конфиг с переопределением классического таббара.
* /app папка с главной страницей (streamlit_app) и страницей навигации.
* /pages - перечень страниц, доступных пользователю для перехода.

## Unit tests
В данном блоке реализован набор базовых позитивных и негативных (где применимо) тестов сущностей БД, управляемых через /routes. Тесты находятся в папке /tests.
Каждый из наборов тестов помечен соответствующим префиксом test_ и может быть проверен независимо.

Тест на создание задачи (**_test_task_**) сделан через имитацию работы воркера - мы создаём уже готовую задачу через CRUD. В файле тестов добавлен соответствующий комментарий. Также присутствует невозможный в данной реализации негативный кейс, описывающий исключительно откат задачи в случае наличия транзакционной системы. Оставлен для иллюстрации, что работа с негативными статусами также возможна.

CI/CD пайплайн настроен не был (не хватило времени). В теории, такой пайплайн мог бы выглядеть так: Линтер -> Автотесты -> Мерж. 
